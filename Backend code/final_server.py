# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QBYqsQORjUYkVMFHZlynyzrNmOwPzVRe
"""

import time
from multiprocessing import Process, Queue, Manager, Value
import time
import socket
import sys
# import picar_4wd as fc
import json
import subprocess

import picar_4wd as fc
from advanced_mapping import *
import math
import heapq
import numpy as np
import argparse
import sys
import time
import cv2
from object_detector import ObjectDetector
from object_detector import ObjectDetectorOptions
import utils
from run_queue import *
from navigation import *

manager = Manager()
completed = manager.list()
all_names = set()
total_orders = 0

curr_item = None
currentloc = (19,0)

class order():
    def __init__(self, name, pickup_loc, dropoff_loc):
      global total_orders
      total_orders += 1
      self.id = total_orders
      self.name = name
      self.pickuploc = pickup_loc
      self.dropoffloc = dropoff_loc

def pickup_order():
  global curr_item
  global currentloc
  print("Picking up", curr_item.name)
  current, face = run_pickup_dropoff(currentloc, curr_item.pickuploc)
  reset_face(face)
  currentloc = current

def dropoff_order():
  global curr_item
  global currentloc
  print("Dropping off", curr_item.name)
  current, face = run_pickup_dropoff(currentloc, curr_item.dropoffloc)
  completed.append(curr_item.name)

  reset_face(face)
  currentloc = current

def run_order():
  pickup_order()
  dropoff_order()
  global curr_item


HOST = "192.168.1.10"
PORT = 8001          # Port to listen on (non-privileged ports are > 1023)


def queuer(q):
  with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind((HOST, PORT))
    s.listen()

    while True:
      client, clientInfo = s.accept()
      data = client.recv(1024).decode('utf-8')      # receive 1024 Bytes of message in binary format

      if len(data) > 1:
        print(data)

      if "GET" in data[:4]:
        all_orders = []

        for item in completed:
          all_orders.append({"name": item, "status": "Delivered!"})

        for item in all_names:
          if item not in completed:
            all_orders.append({"name": item, "status": "In Process"})

        output = {"order_num": total_orders, "orders": all_orders}
        client.send(json.dumps(output).encode())

      elif "POST" in data[:5]:
        print("posting", data[5:])
        data_json = json.loads(data[5:])

        name = data_json["order_name"]
        print(name)
        temp = data_json["pickup_loc"]
        pickuploc = (int(temp[0]), int(temp[1])) # (int, int)
        temp = data_json["dropoff_loc"]
        dropoffloc = (int(temp[0]), int(temp[1])) # (int, int)
          
        q.put(order(name, pickuploc, dropoffloc))
        print("added", name, pickuploc, dropoffloc)
        all_names.add(name)

def worker(q):  
    while True:
        if not q.empty():
          global curr_item
          curr_item = q.get()
          run_order()
        else:
          print ("No jobs")
          time.sleep(1)

if __name__ == '__main__':
    q = Queue()
    a = Process(target=queuer, args=(q,))
    b = Process(target=worker, args=(q,))
    a.start()
    b.start()
    a.join()
    b.join()